---     
  # 1. Verification of the required variables
  - name: Verify required variables are defined
    ansible.builtin.assert:
      that:
        - target_state is defined
      fail_msg: "The variable 'target_state' must be defined (e.g., Started, Stopped)."
    run_once: true
    delegate_to: "{{ active_cluster_node }}"

  # 2. Create a list of resources and groups based on pcs resource config
  - name: Retrieve raw Pacemaker resource configuration
    command: pcs resource config
    register: pcs_config_raw
    changed_when: false
    check_mode: false
    run_once: true
    delegate_to: "{{ active_cluster_node }}"

  - name: Parse resource IDs from configuration
    ansible.builtin.set_fact:
      # Regex looks for lines starting with 'Resource:' or 'Group:' and captures the ID
      # Note: Adjust regex based on your specific 'pcs' version output format if necessary
      pacemaker_resources: "{{ pcs_config_raw.stdout | regex_findall('^\\s*(?:Resource|Group):\\s+([\\w-]+)', multiline=True) }}"
    run_once: true
    delegate_to: "{{ active_cluster_node }}"

  # 3. Display summary of resources
  - name: Display summary of identified resources
    ansible.builtin.debug:
      msg: 
        - "Identified {{ pacemaker_resources | length }} resources/groups."
        - "List: {{ pacemaker_resources }}"
    run_once: true
    delegate_to: "{{ active_cluster_node }}"

  # 4. Verify state and handle transitions (Looping via include_tasks)
  - name: Verify state for each resource
    ansible.builtin.include_tasks: verify_resource.yml
    loop: "{{ pacemaker_resources }}"
    loop_control:
      loop_var: resource_item
    run_once: true
    delegate_to: "{{ active_cluster_node }}"

  # 5. Set facts to be able to access between runs/plays
  - name: Persist resource status facts
    ansible.builtin.set_fact:
      pcmk_verified_resources: "{{ pacemaker_resources }}"
      pcmk_verification_status: "Success"
      cacheable: yes
    run_once: true
    delegate_to: "{{ active_cluster_node }}"
